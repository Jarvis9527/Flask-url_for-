Flask-SQLAlchemy管理数据库：
Flask-SQLAlchemy是一个Flask拓展，简化了在Flask程序中使用SQLAlchemy的操作，
SQLAlchemy是一个很强大的关系型数据库框架，支持多种数据库后台。SQLAlchemy提供了高层ORM，也提供了使用原生SQL的
低层功能。


和其他大多数拓展一样,Flask-SQLAlchemy也使用pip安装：
pip install flask-sqlalchemy

在Flask-SQLAlchemy中，数据库使用URL指定。最流行的数据库引擎采用的数据库URL

Flask-SQLAlchemy数据库URL
数据库引擎：              URL
MySQL                     mysql://username:password@hostname/database
Postgres                  postgresql://username:password@hostname/database
SQLite(Unix)              sqlite:///absolute/path/to/database
SQLite(Windows)           sqlite:///c:/absolute/path/to/databse

在这些URL中，hostname表示MySQL服务所在的主机，可以是本地主机（localhosy）,也可以是远程服务器。数据库服务器上可以托管多个数据库，因此database表示要使用的数据库名。如果数据集需要进行认证，username和password表示数据库用户
密令


SQLite数据库不需要使用服务器，因此不同指定hostname、username和password。URL中的database是硬盘上文件名。

程序使用的数据库URL必须保存到Flask配置对象的SQLALCHEMY_DATABASE_URI键中。配置对象中海油一个很有用的选项，
即SQLALCHEMY_COMMIT_ON_TEARDOWN键，将其设为True时，每次请求结束后都会自动提交数据库中的变动。其他配置选项
的作用请参阅Flask-SQLAlchemy的文档，例如如何初始化及配置一个简单的SQLite数据库。

from flask.ext.sqlalchemy import SQLAlchemy

basedir = os.path.abspath(os.path.dirname(__file__))
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = \
    'sqlite:///' + os.path.join(basedir, 'data.sqlite')
app.config['SQLALCHEMY_COMMIT_ON_TEARDOWN'] = True
db = SQLAlchemy(app)

db对象是SQLAlchemy类的实例，表示程序使用的数据库，同时还获得了Flask-SQLAlchemy提供的所有功能。


定义模型：
模型这个术语表示程序使用的持久化实体。在ORM中，模型一般是一个Python类，类中的属性对应数据库表中的列。
Flask-SQLAlchemy创建的数据库实例为模型提供了一个基类以及一系列辅助类和辅助函数，可用于定义模型的结构
如图：
Role <==> User
定义Role和User模型：
class Role(db.Model):
    __tablename__ = 'roles'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True)
    
    def __repr__(self):
        return '<Role %r>' % self.name

class User(db.Model):
    __tablename__ == 'users'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), unique=True, index=True)

    def __repr__(self):
        return '<User %r>' % self.name

类变量__tablename__定义在数据库中使用的表名，如果没有定义__tablename__.Flask-SQLAlchemy会使用一个默认名字，
但默认的表名没有遵循使用复数形式进行命名的约定，所以最好由我们自己来指定表名，其余的类变量都是该模型的属性，
被定义为db.Column类的实例。

db.Column类构造函数的第一个参数是数据库列和模型属性的类型，列出一些可用的列类型以及在模型中使用的Python类型.
最常用的SQLAlchemy列类型：
类型名：              Python；类型                  说明：
Integer               int                           普通整数，一般是32位
SmallInteger          int                           取值范围小的整数，一般是16位
BigInteger            int或long                     不限制精度的整数
Float                 float                         浮点数
Numeric               decimal.Decimal               定点数
String                str                           变长字符串
Text                  str                           变长字符串，对较长或不限长度的字符串做了优化
Unicode               unicode                       变长Unicode字符串
UnicodeText           unicode                       变长Unicode字符串，对较长或不限长度的字符串做了优化
Boolean               bool                          布尔值
Date                  datetime.date                 日期
Time                  datetime.time                 时间
DateTime              datetime.datetime             日期和时间
Interval              datetime.timedelta            时间间隔
Enum                  str                           一组字符串
PickleType            任何Python对象                自动使用Pickle序列化
LargeBinary           str                           二进制文件

db.Column中其余的参数指定属性的配置选项，列出了一些可用选项。
最常使用的SQLAlchemy列选项：
选项名：                   说明：
primary_key                如果设为True,这列就是表的主键
unique                     如果设为True,这列不允许出现重复的值
index                      如果设为True,为这列创建索引，提升查询效率
nullable                   如果设为True,这列允许使用空值；如果设为False，这列不允许使用空值
default                    为这列定义默认值

Flask-SQLAlchemy要求每个模型都要定义主键，这一列经常命名为id.
虽然没有强制要求，但这两个模型都定义了__repr()__方法，返回一个具有可读性的字符串表示模型，可在调整和测试时使用


关系：
关系型数据库使用关系把不同表中的行联系起来，所示的关系图表示用户和角色之间的一种简单关系。这是角色到用户的一对
多关系，因为一个角色可属于多个用户，而每个用户都只能有一个角色。

例如： 一堆多关系模型类中表示方法
class Role(db.Model):
    # ...
    users = db.relationship('User', backref='role')

class User(db.Model):
    # ...
    role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))

db.ForeignKey：普通整数32位

关系使用users表中的外键里连接了两行。添加到User模型中的role_id列被定义为外键，就是这个外键建立起了关系，传给
db.ForeignKey()的参数 'roles.id'表明，这列的值是roles表中行的id值

添加到Role模型中的users属性代表这个关系的面向对象视角，对于一个Role类的实例，其users属性将返回与角色关联的用户
组成的列表.db.relationship()的第一个参数表名这个关系的另一端是哪个模型。如果模型类尚未定义可使用字符串形式指定

db.relationship()中的backref参数向User模型中添加一个role属性，从而定义反向关系。这一属性可替代role_id访问Role模型，此时获取的是模型对象，而不是外键的值。

大多数情况下，db.relationship()都能自行找到关系中的外键，但有时却无法决定把哪一列作为外键。例如，如果User模型
中有两个或以上的列定义为Role模型的外键，SQLAlchemy就不知道该使用哪列。如果无法决定外键，你就要为
db.relationship()提供额外参数，从而确定所有外键。表中列出了定义关系时常用的配置选项

常用的SQLAlchemy关系选项：
选项名：                  说明：
backref                   在关系的另一个模型中添加反向引用
primaryjoin               明确指定两个模型之间是有的联结条件。只在模棱两可的关系中需要指定
lazy                      指定如何加载相关记录。可选值有select(首次访问时按需加载)、immediate(源对象加载后就加                           载)、joined(加载记录，但是有联结)、subquery(立即加载，但使用子查询)，noload(用不加载)                          和dynamic(不加载记录，但提供加载记录的查询)
uselist                   如果设为False，不使用列表，而使用标量值
order_by                  指定关系中记录的排序方式
secondary                 指定多对多关系中关系表的名字
secondaryjoin             SQLAlchemy无法自行决定时，指定多对多关系中的二级联结条件

除了一堆多之外，还有几种其他的关系类型。一对一关系可以用前面介绍的一对多关系表示，但调用db.relationship()时要
把uselist设为False,把'多'变长'一'。多对一关系也可以用一对多表示，对调两个表即可，或者把外键和db.relationship()
都








































